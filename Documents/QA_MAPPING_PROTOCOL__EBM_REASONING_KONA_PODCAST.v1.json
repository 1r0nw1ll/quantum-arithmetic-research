{
  "protocol_version": "QA_MAPPING_PROTOCOL.v1",
  "mapping_id": "ebm_reasoning_kona_podcast_v1",
  "state_manifold": {
    "state_type": "Hybrid reasoning state s = (problem, constraints, candidate_state, energy E_task(s), optional QA core (b,e) with derived packet, verifier_status).",
    "embedding_function": "Clamp observations into a structured state; when QA core is used: (b,e) primitives with derived coordinates (d=b+e, a=b+2e) and 21-element invariant packet. Define an exact-scalar energy E_task(s) as a deterministic penalty sum over violated constraints/invariants. Treat language as a non-authoritative codec into constraints/objectives; accept candidates only via invariant gates and (optionally) external verifier.",
    "constraints": [
      "If QA core is used: (b,e) ∈ ℤ₊² with b,e>0; d=b+e; a=b+2e; d,a never independent (qa_canonical §1).",
      "Failures are deterministic and reproducible (qa_canonical §5.2).",
      "Generators are partial functions: unique successor when legal, otherwise typed Fail(s,g)=(move, fail_type, ΔI) (qa_canonical §5.1).",
      "Hard constraints must be enforced as gates; soft constraints may shape E_task but cannot replace gates in safety-critical contexts."
    ]
  },
  "generators": [
    {
      "name": "sigma",
      "transition_rule": "σ(b, e) = (b, e+1) with legality e+1 ≤ N; otherwise FAIL OUT_OF_BOUNDS.",
      "invariant_effect": "Preserves integer manifold and derived coordinates; emits deterministic OUT_OF_BOUNDS failure when caps violated."
    },
    {
      "name": "mu",
      "transition_rule": "μ(b, e) = (e, b) (always legal on Caps(N,N)).",
      "invariant_effect": "Preserves integer manifold; pairs off-diagonal states into 2-cycles (SCC size ≤ 2 under μ-only cycles)."
    },
    {
      "name": "lambda2",
      "transition_rule": "λ₂(b, e) = (2b, 2e) with legality 2b ≤ N and 2e ≤ N; otherwise FAIL OUT_OF_BOUNDS.",
      "invariant_effect": "Preserves integer manifold and derived coordinates; emits deterministic OUT_OF_BOUNDS failure when caps violated."
    },
    {
      "name": "nu",
      "transition_rule": "ν(b, e) = (b/2, e/2) if b,e both even; otherwise FAIL PARITY.",
      "invariant_effect": "Preserves integer manifold under evenness; emits deterministic PARITY failure on odd coordinates."
    },
    {
      "name": "ebm_descent_policy",
      "transition_rule": "Given a state s, choose a legal generator g ∈ Σ_full that minimizes E_task(g(s)) with deterministic tie-break; apply it; otherwise emit typed FAIL with ΔI witness.",
      "invariant_effect": "Implements energy-guided reachability search; must emit invariant_diff witness (ΔI / energy delta / violation deltas) per step and never bypass hard gates."
    },
    {
      "name": "llm_codec",
      "transition_rule": "Compile language intent into explicit constraints/objectives (non-authoritative). If under-specified or contradictory, emit a typed failure with witness.",
      "invariant_effect": "Introduces an interface boundary; must surface interface-loss and cannot override invariant gates."
    },
    {
      "name": "verifier_check",
      "transition_rule": "Run external verifier (Lean/SMT/custom) on candidate; return ACCEPTED or REJECTED with obstruction witness.",
      "invariant_effect": "Turns correctness into a hard accept/reject gate; on REJECTED must provide witness (unsat core / failing theorem / type error / timeout)."
    }
  ],
  "invariants": [
    {
      "name": "qa_state_space",
      "definition": "(b, e) ∈ ℤ₊² with b,e>0; d=b+e; a=b+2e; d and a are always derived (qa_canonical §1)."
    },
    {
      "name": "qa_invariant_packet_exact_arithmetic",
      "definition": "Invariant packet includes L=(C·F)/12 as an exact rational Fraction(C*F,12), and I=|C-F| positive (qa_canonical §1.3, §9.1)."
    },
    {
      "name": "failures_are_theorems",
      "definition": "Failures are deterministic and reproducible, not stochastic (qa_canonical §5.2, §9.1)."
    },
    {
      "name": "determinism_contract",
      "definition": "Generators are partial functions: unique successor when legal; otherwise typed Fail(s,g)=(move, fail_type, ΔI) (qa_canonical §5.1)."
    },
    {
      "name": "hard_invariant_gates",
      "definition": "Hard constraints/invariants must be enforced as gates; E_task shaping is not sufficient for safety-critical acceptance."
    },
    {
      "name": "verifier_gate_for_critical_outputs",
      "definition": "Safety-critical outputs are accepted only if verifier_check returns ACCEPTED; otherwise VERIFIER_REJECTED with witness."
    }
  ],
  "failure_taxonomy": [
    {
      "fail_type": "OUT_OF_BOUNDS",
      "trigger_condition": "Attempted σ or λ₂ step exceeds Caps(N,N) boundary (qa_canonical §5.2)."
    },
    {
      "fail_type": "PARITY",
      "trigger_condition": "Attempted ν step when b or e is odd (qa_canonical §5.2)."
    },
    {
      "fail_type": "PHASE_VIOLATION",
      "trigger_condition": "Move breaks fixed-q constraint (qa_canonical §5.2)."
    },
    {
      "fail_type": "INVARIANT",
      "trigger_condition": "Derived constraint violated (rare in Caps; occurs in other QA universes) (qa_canonical §5.2)."
    },
    {
      "fail_type": "REDUCTION",
      "trigger_condition": "Non-reduction axiom violated when active (qa_canonical §5.2)."
    },
    {
      "fail_type": "INTERFACE_LOSS",
      "trigger_condition": "llm_codec produces under-specified/ambiguous/contradictory constraints; must emit witness describing what was lost."
    },
    {
      "fail_type": "VERIFIER_REJECTED",
      "trigger_condition": "verifier_check rejects candidate; must emit obstruction witness (unsat core / failing theorem / type error / timeout)."
    },
    {
      "fail_type": "BUDGET_EXHAUSTED",
      "trigger_condition": "Descent/agentic loop hits time/step budget without reaching target class; must emit obstruction evidence (e.g., SCC witness or bounded non-reachability report)."
    }
  ],
  "reachability": {
    "graph_type": "Directed transition graph induced by generators Σ over the state manifold (qa_canonical §7).",
    "component_analysis": "Use return_in_k(s→R*,k,Σ) decidable via bounded BFS; SCC monotonicity under generator expansion; connectivity transition on Caps(30,30) when expanding to Σ₃={σ,μ,λ₂,ν} (qa_canonical §6–7)."
  },
  "determinism_contract": {
    "invariant_diff_defined": true,
    "nondeterminism_proof": "Per qa_canonical: generators are partial functions with deterministic legality and typed Fail(s,g) outputs. For EBM navigation, the descent policy must be deterministic via declared tie-break rules and must emit invariant_diff (ΔI / energy delta / violation deltas) at each step; otherwise nondeterminism is a typed failure."
  }
}

